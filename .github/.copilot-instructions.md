## Core Principles

Write clean, maintainable, and type-safe Python code that prioritizes readability, robustness, and modern Python idioms. Always assume Python 3.10 or later is available.

**⚠️ IMPORTANT: Acton Agent is an EXPERIMENTAL project.** Always describe it as "experimental" rather than "production-ready". The API may change without notice. Avoid using production terminology in documentation and code to maintain accurate expectations about the project's maturity level.

---

## Project Structure

The Acton Agent framework follows a modular architecture:

```
acton-agent/
├── acton_agent/           # Main package
│   ├── __init__.py        # Public API exports
│   ├── agent/             # Core agent implementation
│   │   ├── agent.py       # Agent class
│   │   ├── exceptions.py  # Custom exceptions
│   │   ├── models.py      # Data models (Message, AgentPlan, etc.)
│   │   ├── prompts.py     # System prompts
│   │   └── retry.py       # Retry configuration
│   ├── client/            # LLM client implementations
│   │   ├── base.py        # LLMClient protocol
│   │   ├── openai_client.py
│   │   └── openrouter.py
│   ├── memory/            # Conversation memory management
│   │   ├── base.py        # AgentMemory protocol
│   │   └── simple.py      # SimpleAgentMemory implementation
│   ├── parsers/           # Response parsing
│   │   ├── base.py        # ResponseParser
│   │   └── streaming.py   # Streaming parser
│   └── tools/             # Tool system
│       ├── base.py        # Tool base class
│       ├── function_tool.py
│       ├── models.py      # ToolSet, ToolCall, ToolResult
│       ├── registry.py    # ToolRegistry
│       └── requests_tool.py
├── docs/                  # Documentation
│   ├── README.md          # Documentation index
│   ├── getting-started.md
│   ├── core-concepts.md
│   ├── api-reference.md
│   ├── faq.md
│   └── examples/          # Documentation examples
│       └── README.md
├── examples/              # Runnable example scripts
│   ├── function_tool_example.py
│   ├── custom_tool_example.py
│   ├── requests_tool_example.py
│   └── toolset_params_example.py
├── tests/                 # Test suite
│   ├── conftest.py        # Shared fixtures
│   ├── test_agent.py
│   ├── test_tools.py
│   └── ...                # Other test files
├── .github/
│   ├── .copilot-instructions.md  # This file
│   ├── instructions/             # Additional instructions
│   └── workflows/                # CI/CD workflows
├── pyproject.toml         # Project metadata and dependencies
└── setup.py               # Setup script
```

### Key Packages

- **acton_agent.agent**: Core Agent class, models, exceptions, and prompts
- **acton_agent.client**: LLM client implementations and protocol
- **acton_agent.memory**: Conversation history management
- **acton_agent.parsers**: Response parsing and streaming
- **acton_agent.tools**: Tool system (base, FunctionTool, registry)

### Public API

The main `__init__.py` exports the most commonly used classes:
- `Agent`, `AgentMemory`, `SimpleAgentMemory`
- `LLMClient`, `OpenAIClient`, `OpenRouterClient`
- `Tool`, `FunctionTool`, `ToolSet`, `ToolRegistry`
- `ResponseParser`, `parse_streaming_events`

Less commonly used classes (like `AgentToken`, `Message`, etc.) are available from their respective subpackages (`acton_agent.agent`, `acton_agent.tools`, etc.).

---

## Documentation Standards

### Docstring Format

Use the following format for all public functions, classes, and methods:

```python
"""
Short description of what the function/method does.

Parameters:
    param_name (type): Description of parameter.
    another_param (type): Description of another parameter.

Returns:
    return_name (type): Description of what is returned.

Raises:
    ExceptionType: Description of when this exception is raised.
    AnotherException: Description of another exception condition.
"""
```

**Requirements:**
- Always include Parameters, Returns, and Raises sections where applicable
- Use descriptive parameter and return value names
- Document all exceptions that can be raised
- Keep descriptions clear and concise
- Add module-level docstrings explaining purpose and contents
- Document class attributes and their purposes

---

## Type Hints

### Use Modern Type Annotations (Python 3.10+)

- Use built-in types: `list[str]`, `dict[str, int]` instead of `List[str]`, `Dict[str, int]`
- Use union operator: `str | int | None` instead of `Union[str, int, None]`
- Use `TypeAlias` for complex type definitions
- Always add type hints to function parameters and return values
- Use `Protocol` for structural subtyping
- Use `TypeVar` and `Generic` for generic classes
- Prefer specific types over `Any`

---

## Code Quality & Linting

### Pre-Commit Requirements

**CRITICAL: Before every commit, you MUST run:**

```bash
ruff check .
ruff format .
mypy .
```

- Fix **ALL** errors reported by `ruff check`
- Allow `ruff format` to automatically format your code
- Fix **ALL** type errors reported by `mypy`
- **Do not commit code with any linting or type errors**
- Configure pre-commit hooks to enforce this automatically

---

## Error Handling

### Exception Handling

- Create custom exception classes for domain-specific errors
- Catch specific exceptions, **never use bare `except:`**
- Avoid catching broad `Exception` unless necessary
- Always log exceptions appropriately
- Use exception chaining with `raise ... from ...`
- Provide meaningful error messages with context

### Resource Management

- Use context managers for all resource management (files, connections, locks)
- Implement custom context managers when appropriate
- Ensure proper cleanup in `finally` blocks or `__exit__` methods

---

## Modern Python Features (3.10+)

### Pattern Matching

Use `match`/`case` statements for complex conditional logic when it improves readability over if/elif chains.

### Dataclasses

- Use `@dataclass` for simple data containers
- Use `frozen=True` for immutable data classes
- Use `field(default_factory=...)` for mutable defaults
- Consider Pydantic `BaseModel` when validation is needed

### Other Features

- Use structural pattern matching where appropriate
- Leverage new union type syntax (`X | Y`)
- Use `TypeAlias` for complex type definitions

---

## Code Organization

### Module Structure

- Organize code into logical modules (models, services, utils, config)
- Keep related functionality together
- Use `__init__.py` to expose public APIs
- Avoid circular imports

### Class Design

- Follow Single Responsibility Principle
- Use composition over inheritance
- Keep classes focused and cohesive
- Use abstract base classes for common interfaces
- Use properties for computed attributes

### Function Design

- Keep functions short and focused (aim for under 50 lines)
- Functions should do one thing well
- Use descriptive names
- Return early to avoid deep nesting
- Minimize side effects

---

## Best Practices

### Logging

- **NEVER use `print()` statements** - always use proper logging
- Use appropriate log levels (debug, info, warning, error, critical)
- Include relevant context in log messages
- Use structured logging when available
- Log exceptions with full stack traces

### Path Operations

- Always use `pathlib.Path` instead of `os.path`
- Use Path methods (`.exists()`, `.read_text()`, `.write_text()`)
- Never manually concatenate path strings

### String Formatting

- Use f-strings for all string formatting
- Avoid `%` formatting and `.format()` method

### Comprehensions

- Use list/dict/set comprehensions for simple transformations
- Don't over-complicate comprehensions - use loops for complex logic
- Use generator expressions for memory efficiency

### Imports

Organize imports in three groups, separated by blank lines:
1. Standard library imports
2. Third-party imports
3. Local application imports

Sort imports alphabetically within each group.

### Constants and Configuration

- Use `Enum` for related constants
- Use `UPPER_SNAKE_CASE` for module-level constants
- Don't hard-code values - use configuration

---

## Testing with Pytest

### Test Organization

- Name test files: `test_*.py`
- Name test functions: `test_*`
- Name test classes: `Test*`
- Use descriptive test names that explain what is being tested
- Mirror source code structure in test organization
- Place tests in `tests/` directory

### Writing Tests

- Test one thing per test function
- Test both success and failure paths
- Test edge cases and boundary conditions
- Use parametrized tests (`@pytest.mark.parametrize`) for multiple similar cases
- Write clear, specific assertions
- Include helpful assertion messages when needed

### Fixtures

- Use fixtures for common test setup and teardown
- Define fixtures in `conftest.py` for sharing across test files
- Use appropriate fixture scopes: `function` (default), `class`, `module`, `session`
- Use `autouse=True` sparingly
- Name fixtures descriptively

### Mocking

- Mock external dependencies (APIs, databases, file systems)
- Use `unittest.mock` or `pytest-mock`
- Mock at the appropriate level (mock interfaces, not implementations)
- Verify mock calls when testing interactions
- Clean up mocks after tests


### Test Coverage

- Aim for high test coverage (80%+ recommended)
- Don't just chase coverage numbers - write meaningful tests
- Use `pytest-cov` to measure coverage
- Test critical paths thoroughly

---

## Performance Considerations

### Generators and Iterators

- Use generators for processing large datasets
- Use generator expressions when consuming data once
- Implement `__iter__` for custom iterables

### Caching

- Use `@lru_cache` from `functools` for expensive pure functions
- Configure appropriate `maxsize` based on memory constraints
- Be aware of memory implications

---

## Naming Conventions (PEP 8)

- **Modules/Packages**: `lowercase_with_underscores`
- **Classes**: `PascalCase`
- **Functions/Methods**: `lowercase_with_underscores`
- **Constants**: `UPPER_CASE_WITH_UNDERSCORES`
- **Variables**: `lowercase_with_underscores`
- **Private attributes/methods**: `_single_leading_underscore`
- **Name mangling**: `__double_leading_underscore` (rare, avoid unless needed)

Use descriptive names that clearly convey purpose. Clarity over brevity.

---

## Code Style

### General Guidelines

- Maximum line length: 120 characters (or as configured in project)
- Use 4 spaces for indentation (never tabs)
- Use blank lines to separate logical sections
- Keep related code together
- Remove commented-out code and dead code

### Code Smells to Avoid

- Deep nesting (more than 3-4 levels)
- Long parameter lists (more than 5 parameters)
- Long functions (more than 50 lines)
- Duplicated code
- Magic numbers (use named constants)
- Mutable default arguments
- Broad exception catching

---

## Summary Checklist

### Before Every Commit
- ✅ Run `ruff check .` and fix **all** errors
- ✅ Run `ruff format .` to auto-format code
- ✅ Run `mypy .` and fix **all** type errors
- ✅ Run `pytest` and ensure all tests pass
- ✅ Verify test coverage is adequate
- ✅ Review your code for clarity and correctness

### Documentation
- ✅ Add docstrings to all public functions, classes, and methods
- ✅ Use specified docstring format with Parameters/Returns/Raises
- ✅ Document module purposes
- ✅ Document complex logic with inline comments

### Type Safety
- ✅ Add type hints to all parameters and return values
- ✅ Use Python 3.10+ type syntax
- ✅ Define TypeAlias for complex types
- ✅ Avoid using `Any` when possible

### Code Quality
- ✅ Never use `print()` - use logging
- ✅ Use `pathlib.Path` for file operations
- ✅ Handle exceptions properly with specific exception types
- ✅ Use context managers for resource management
- ✅ Follow naming conventions (PEP 8)
- ✅ Keep functions short and focused
- ✅ Avoid code duplication

### Testing
- ✅ Write tests for all new functionality
- ✅ Test success and failure cases
- ✅ Test edge cases
- ✅ Use fixtures appropriately
- ✅ Mock external dependencies
- ✅ Use descriptive test names


### Code Organization
- ✅ Organize imports properly (stdlib, third-party, local)
- ✅ Keep related code together
- ✅ Follow Single Responsibility Principle
- ✅ Use appropriate module structure